---
cip: 145
title: Multiple previous (multi-prev)
author: Aaron Goldman (@aarongoldman), Mohsin Zaidi (@smrz2001)
discussions-to: https://forum.ceramic.network/t/cip-145-multiple-previous-multi-prev/1277
status: Draft
category: Core
created: 2023-08-21
edited: 2023-08-31
---

## Simple Summary
Adding the ability to merge diverged branches of a Ceramic stream.

## Abstract
This CIP adds the ability to merge diverged branches of a stream. It describes a modification to the `prev` field for a
Ceramic event so that it can be either a single CID or a list of CIDs (hereinafter referred to as **multi-prev**).

For a `prev` that is a list of CIDs, the aggregation layer may treat these CIDs differently depending on the order. How
this order is interpreted is an implementation detail outside the scope of this spec.

## Motivation
A Ceramic stream can fork if two different events both have the same CID in their `prev` field. This can happen for
various legitimate reasons.

For example, two or more Ceramic nodes generate Data Events to the same Ceramic stream before learning of events
generated from the other node(s).

A special case of this is a race between new Data Events being generated to a stream and Time Events corresponding to
older Data Events in the stream. This type of fork in a stream is easily possible and can only be addressed at the
protocol level. Prior to this CIP, Time Events and Data Events were not considered by the branch pruning rules described
below, and would result in pruning of Data Events coinciding with Time Events.

### Definitions
* A Ceramic `synchronization layer` synchronizes all the events for a Ceramic stream.
* A Ceramic `aggregation layer` converts all the events in a Ceramic stream to its corresponding tip state.
* A `branch` for an event is the set of all events transitively covered by that event. 
* A `pruned branch` is any branch that is not covered by the tip.
* A `fork point` for a branch is the earliest event on that branch that is not on another branch. 
* A `merge point` for two events is an event that transitively covers both events.
* `A` is a `covered event` if another event `B` has `A`'s CID in its `prev` field.
    * Said differently, if event `B` has event `A`'s CID in its `prev` field, then event `B` "covers" event `A`. By
      transitivity, event `B` also covers every event covered by event `A`.
    * The `time` of a Data Event is the timestamp of the earliest Time Event that covers the Data Event.
* `A` is an `uncovered event` if there is no event with `A`'s CID in its `prev` field.
* A `dominant Data Event` is one that is not covered by another Data Event.
* A `non-dominant Data Event` is one that is covered by another Data Event. This applies transitively through Time
  Events.
* A `diverged stream` has more than one dominant Data Event.
* A `converged stream` has a single dominant Data Event.
* An `invalid Data Event` is one that has either an invalid signature or an expired CACAO.
* A `valid Data Event` is one that has a valid signature and a valid CACAO (if applicable).

## Specification

Any stream where there are Data Events without a common descendant is in a diverged state. When a stream diverges,
Ceramic uses the rules below to determine which of the uncovered events will serve as the tip of the stream and which
branches are pruned. Since pruning branches that contain Data Events would result in the pruning of valid data, we allow
a Data Event to contain multiple ancestor events in its `prev` field so that a new merge point Data Event can cover
multiple events.

1. If a stream is in a diverged state, each uncovered event is a candidate tip.
2. Branches that do not contain dominant Data Events cannot be the tip.
3. For branches that contain dominant Data Events, consider the earliest Data Event after a fork point.
4. The branch with the earliest Data Event becomes the tip.
5. If multiple earliest Data Events have the same time, then the Data Event with the lowest CID becomes the tip.

For an example of these rules in action, see the figure below:
![Alt text](../assets/cip-145/rules1.png)

1. Based on rule (1), the stream state has 4 candidate tips, `Time 5`, `Time 6`, `Time 4`, and `Data F`. One of these
   candidate tips will become the tip of the stream.
   ![Alt text](../assets/cip-145/rules2.png)
2. The stream forks between the branches for `Time 1` and `Data A`. Based on rules (3) and (4), the branch for `Data A`
   is the only branch considered for tip selection.
   ![Alt text](../assets/cip-145/rules3.png)
3. This branch later forks into additional branches for `Data E`, `Time 4`, and `Data F`. Based on rules (3) and (4),
   the branches for `Data E` and `Data F` are the only branches considered for tip selection.
   ![Alt text](../assets/cip-145/rules4.png)
4. Based on rule (5), since there is a Time Event for `Data E` but not for `Data F`, only the branch for `Data E` is
   considered for tip selection.
   ![Alt text](../assets/cip-145/rules5.png)
5. `Time 6` is the tip of the surviving branch, and therefore becomes the tip of the stream.
   ![Alt text](../assets/cip-145/rules6.png)

Using multi-prev Data Events allows us to reduce the number of dominant Data Events and converge the stream so that
there is only a single dominant Data Event, without any data abandoned on pruned branches. The stream's
converged/diverged state can be determined by looking at the `prev` fields of all the Data Events for that stream.

Events that have invalid signatures cannot be tips, even if uncovered. This has important implications for Data Events
with expired CACAOs. In figures 5 and 6, if we assume event `A` has an expired CACAO, the aggregation layer can choose
to repair the stream by creating a new Data Event `C` with `{ "prev": [CID_Data_B, CID_Time_2] }`. This effectively
prunes the branch with Time Event `2` and merges Data Event `B` into the new event `C`. How this merge is implemented is
at the discretion of the aggregation layer.

### Example
> ![lattice](../assets/cip-145/lattice.png)
> 
> Fig. 1: A lattice where `1`, `2`, `3` are canonical Data Events (with corresponding Time Events) and `A`, `B` are
> events on a pruned branch. `2` and `A` both have `prev: 1's CID` thereby creating a fork. `3` has a multi-prev
> `prev: [2's CID, B's CID]`, thereby converging the pruned branch back into the stream.

---

> ![Alt text](../assets/cip-145/ex1.png)
>
> Fig. 2: An Init Event is created. The tip of this stream is `Init`, and the stream is anchored at Null.

---

> ![Alt text](../assets/cip-145/ex2.png)
>
> Fig. 3: The Init Event gets anchored and a Time Event is created. The tip of this stream is `Init`, and the stream is
> anchored at Init.

---

>![Alt text](../assets/cip-145/ex3.png)
>
> Fig. 4: Data Event `A` branches off of `Init` not Time Event `1` but there are no Data Events following `1`, so `A` is
> the tip, and the stream is anchored at `A`.

This CIP changes the interpretation of this scenario. Prior to the CIP, the stream would have been anchored at `Init`
but will now be anchored at `A`.

---

> ![Alt text](../assets/cip-145/ex4.png)
>
> Fig. 5: Continuing from fig. 4, Data Event `B` branches off of Time Event `1` and is anchored at Time `3`. `B` happens
> later than Data Event `A`, so the tip is still `A`. We are now in a diverged state as `B` is on a pruned branch.

This CIP changes the interpretation of this scenario. Prior to the CIP, the stream would have been anchored at `B` but
will now be anchored at `A`.

---

> ![Alt text](../assets/cip-145/ex5.png)
>
> Fig. 6: The controller fixes the diverged state by creating a new merge point Data Event `C`, which has a multi-prev
> covering both Time Event `2` and Data Event `B`. `C` is now the tip, and the stream is anchored at `C`.

---

## Backwards Compatibility
Nodes that do not implement this CIP will not understand events with `prev` fields containing multiple CIDs but all
existing streams and events with single `prev` CIDs remain valid.

The branch pruning rules specified in this document supersede the existing Ceramic
[stream consensus rules](https://github.com/ceramicnetwork/docs/blob/main/docs/protocol/streams/consensus.md) given
below, even for streams with single `prev` CIDs.

The main change in this CIP is that we only consider valid Data Events to be candidates for stream tips. This CIP also
drops rule 4 below for considering the length of the stream log after the last Time Event. This eliminates fluctuation
between diverged branches following the addition of new Data Events. This, in turn, prevents the stream from alternating
which branch was pruned.

> A tip and canonical log for a stream are selected by the following pseudo algorithm and rules:
>
> 1. Given a set of tips, traverse each tree path from tip till a commonly shared Time Event or the Init Event.
> 2. From the shared event, traverse each path in the opposite direction (towards tip) until a Time Event is found (or
>    the end of the log is reached). This set of events are considered conflicting events.
> 3. Given each Time Event, determine the blockheight for the transaction included in the timestamp proof. Select the
>    path with lowest blockheight. If a single path is selected, exit with path and tip selected, otherwise continue.
>    Most cases will terminate here, it will be rare to have the same blockheight.
> 4. If multiple tips have the same blockheight, select the path with the greatest number of events from the last
>    timestamp proof till tip. If single path selected, exit with path and tip selected, otherwise continue.
> 5. If number of events is equal, chooses the event and path which has the smallest CID in binary format (an arbitrary
>    but deterministic choice).

## Implementation

legacy `prev`
```json
{ "prev": "CID1"}
```

multi-prev `prev`
```json
{ "prev": ["CID1", "CID2", "CID3"] }
```

Each string in a multi-prev list MUST be a CID. `["CID1"]` or `"CID1"` are treated exactly the same.

## Security Considerations
This CIP improves the robustness of the Ceramic protocol by reconciling data that could otherwise have been abandoned
due to the previous stream consensus rules.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
